# This module defines functions that can be used to check whether OpenMP is
# available and if so what flags to use. To use this, import the
# add_openmp_flags_if_available function in a setup_package.py file where you
# are defining your extensions:
#
#     from astropy_helpers.openmp_helpers import add_openmp_flags_if_available
#
# then call it with a single extension as the only argument:
#
#     add_openmp_flags_if_available(extension)
#
# this will add the OpenMP flags if available.

from __future__ import absolute_import, print_function

import datetime
import glob
import os
import subprocess
import sys
import tempfile
import time

from distutils import log
from distutils.ccompiler import new_compiler
from distutils.sysconfig import customize_compiler, get_config_var
from distutils.errors import CompileError, LinkError

from .setup_helpers import get_compiler_option

__all__ = ['add_openmp_flags_if_available']


CCODE = """
#include <omp.h>
#include <stdio.h>
int main(void) {
  #pragma omp parallel
  printf("nthreads=%d\\n", omp_get_num_threads());
  return 0;
}
"""

def _split_option_from_var(option, var, delim=' '):
    if not var or not option:
        return None
    l = len(option)
    if not l:
        return None

    if var in os.environ:
        for flag in os.environ.split(delim):
            if option in flag[:l]:
                return flag[l:]

    # os.environ was unsuccesful so Look in sysconfig
    try:
        flags = get_config_var(var)
    except KeyError:
        return None
    if flags:
        for flag in flags.split(delim):
            if option in flag[:l]:
                return flag[l:]
    return None

def _get_include_path():
    return _split_option_from_var('-I', 'CFLAGS')

def _get_library_path():
    return _split_option_from_var('-L', 'LDFLAGS')

def add_openmp_flags_if_available(extension):
    """
    Add OpenMP compilation flags, if available (if not a warning will be
    printed to the console and no flags will be added)

    Returns `True` if the flags were added, `False` otherwise.
    """

    ccompiler = new_compiler()
    customize_compiler(ccompiler)
    
    # customize_compiler() extracts info from os.environ. If certain keys
    # exist it uses these plus those from sysconfig.get_config_vars().
    # If the key is missing in os.environ it is not extracted from 
    # sysconfig.get_config_var(). E.g. 'LDFLAGS' get left out, preventing
    # clang from finding libomp.dylib because -L<path> is not passed to linker.
    compile_flags = []
    include_path = _get_include_path()
    if include_path:
        compile_flags.append('-I' + include_path)
    
    link_flags = []
    lib_path = _get_library_path()
    if lib_path:
        link_flags.append('-L' + lib_path)

    tmp_dir = tempfile.mkdtemp()

    start_dir = os.path.abspath('.')

    if get_compiler_option() == 'msvc':
        compile_flags.append('-openmp')
    else:
        compile_flags.append('-fopenmp')
        link_flags.append('-fopenmp')
        if lib_path:
            link_flags.append('-Wl,-rpath,' + lib_path)

    try:

        os.chdir(tmp_dir)

        with open('test_openmp.c', 'w') as f:
            f.write(CCODE)

        os.mkdir('objects')

        # Compile, link, and run test program
        ccompiler.compile(['test_openmp.c'], output_dir='objects', extra_postargs=compile_flags)
        ccompiler.link_executable(glob.glob(os.path.join('objects', '*' + ccompiler.obj_extension)), 'test_openmp', extra_postargs=link_flags)
        output = subprocess.check_output('./test_openmp').decode(sys.stdout.encoding or 'utf-8').splitlines()

        if 'nthreads=' in output[0]:
            nthreads = int(output[0].strip().split('=')[1])
            if len(output) == nthreads:
                using_openmp = True
            else:
                log.warn("Unexpected number of lines from output of test OpenMP "
                         "program (output was {0})".format(output))
                using_openmp = False
        else:
            log.warn("Unexpected output from test OpenMP "
                     "program (output was {0})".format(output))
            using_openmp = False

    except (CompileError, LinkError):

        using_openmp = False

    finally:

        os.chdir(start_dir)

    if using_openmp:
        log.info("Compiling Cython/C/C++/ extension with OpenMP support")
        if extension:
            extension.extra_compile_args.extend(compile_flags)
            extension.extra_link_args.extend(link_flags)
    else:
        log.warn("Cannot compile Cython extension with OpenMP, reverting to non-parallel code")

    return using_openmp

_IS_OPENMP_ENABLED_SRC = """
# Autogenerated by {packagetitle}'s setup.py on {timestamp!s}

def is_openmp_enabled():
    return {return_bool}
"""[1:]

def generate_openmp_enabled_py(packagename, srcdir='.'):
    """
    Utility for creating openmp_enabled.py::is_openmp_enabled()
    used to determine, post build, whether the package was built
    with or without OpenMP support.
    """

    if packagename.lower() == 'astropy':
        packagetitle = 'Astropy'
    else:
        packagetitle = 'Astropy-affiliated package ' + packagename

    is_openmp_enabled = add_openmp_flags_if_available(None)

    epoch = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))
    timestamp = datetime.datetime.utcfromtimestamp(epoch)

    src = _IS_OPENMP_ENABLED_SRC.format(packagetitle=packagetitle,
                                        timestamp=timestamp,
                                        return_bool=is_openmp_enabled)

    package_srcdir = os.path.join(srcdir, *packagename.split('.'))
    is_openmp_enabled_py = os.path.join(package_srcdir, 'openmp_enabled.py')
    with open(is_openmp_enabled_py, 'w') as f:
        f.write(src)
